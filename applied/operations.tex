\documentclass[11pt,fleqn]{article}
\usepackage{amsmath}
\usepackage{changepage}% http://ctan.org/pkg/changepage
\numberwithin{equation}{subsection}
\usepackage[parfill]{parskip}
\setlength{\marginparwidth}{0pt}
\usepackage{layout}
\begin{document}
\title{Aetherling Nodes and Example Pipelines}

\section{Type Notation}

\subsection{Combinational Element Types}
The type signature of combinational elements is:
\begin{adjustwidth}{2.5 em}{0 pt}
    input 1 type $\rightarrow$ ... $\rightarrow$ input n type $\rightarrow$ output type
\end{adjustwidth}
Since these elements require only combinational logic, they must complete all
logic each cycle. Therefore, their input and output types are over
an implicit stream. This means that that they operate on one of each input every 
clock cycle and emit one output every clock cycle. Also, they do not need
ready-valid signals.

Each input or output has type T or T[p]. T is a base type, and it can contain 
nested types like arrays that are not relevant for the current operation. T[p] 
is an array of length p of T's. T[p][q] is an array of length p of arrays of 
length q of T's.

\subection{Sequential Element Types}
The type signature of sequential elements is:
\begin{adjustwidth}{2.5 em}{0 pt}
    \{input 1 num cycles, input 1 type per cycle\} $\rightarrow$ ...
    $\rightarrow$ \{input n num cycles, input n type per cycle\} $\rightarrow$
    \{ouput num cycles, output type per cycle\}
\end{adjustwidth}
Since these operations require sequential logic, their interfaces also must have
clock inputs and may have ready-valid inputs and outputs. These handshake ports
indicate:
\begin{enumerate}
        \item ready
            \subitem input: indicates to this sequential element that the next 
            one in the pipeline has completed its prior input stream and is 
            ready to receive more input.
            \subitem output: indicates to the previous sequential element in the 
            pipeline that this one has completed its prior input stream and is
            ready to receive more input.
        \item valid
            \subitem input: indicates to this sequential element that the previous
            one in the pipeline is emitting valid data that this sequential 
            element can use as input.
            \subitem output: indicates to the next sequential element in the
            pipeline that this one is emitting valid data that the next one
            can use as input.
\end{enumerate}

\section{Basic Elements}
These are elements that are not built using other Aetherling elements.

\subsection{Combinational Elements}

\begin{adjustwidth}{2.5 em}{0 pt}
    tuple :: S $\rightarrow$ T $\rightarrow$ (S,T) \\
    lb p w :: T[p] $\rightarrow$ T[w+p-1] \\
    overlap\_partition p w :: T[w+p-1] $\rightarrow$ T[p][w] \\
    partition p k :: T[k] $\rightarrow$ T[k/p][p] \\
    flatten p k :: T[k/p][p] $\rightarrow$ T[k] \\
    map p f :: S[p] $\rightarrow$ T[p]   \qquad s.t. f :: S $\rightarrow$ T \\
    reduce p f :: T[p] $\rightarrow$ T \qquad s.t. f :: (T,T)$\rightarrow$ T \\
    up k :: T $\rightarrow$ T[k] \\
    down k :: T[k] $\rightarrow$ T \\
    zip :: (S[k],T[k]) $\rightarrow$ (S,T)[k] \\
    unzip :: (S,T)[k] $\rightarrow$ (S[k], T[k]) \\
    mem\_read p :: () $\rightarrow$ T[p] \\
    mem\_write p :: T[p] $\rightarrow$ ()
\end{adjustwidth}

\subsection{Sequential Elements}

\begin{adjustwidth}{2.5 em}{0 pt}
    \text{serialize}\;k :: \{1, T[k]\} \rightarrow \{k, T\}
    \text{deserialize}\;k :: \{k, T\} \rightarrow \{1, T[k]\}
\end{adjustwidth}

\subsubsection{Ready-Valid Connector Operations}
Any block of logic that doesn't run at full rate will need to either start or 
end with sequential operation that changes rate, like serialize or deserialize.
In order to connect this block with other blocks, it will need a ready valid.



\section{Basic Applications}
These are simple combinations of the 
\subsection{Passthrough}
\begin{enumerate}
    \item mem\_write 1 \$ mem\_read 1 
    \item mem\_write t \$ mem\_write t
\end{enumerate}

\subsection{Array-Stream Conversions}
\begin{enumerate}
    \item mem\_write 1 \$ deserialize t \$ mem\_read t
        \subitem Note that mem\_read fires onces every t'th clock cycle
    \item mem\_write 1 \$ deserialize t \$ serialize t \$ mem\_read 1
        \subitem Note mem\_write fires every t'th clock cycle
\end{enumerate}

\subsection{Map}
\begin{enumerate}
    \item mem\_write 1 \$ map 1 f \$ mem\_read 1
    \item mem\_write t \$ map t f \$ mem\_read t
    \item mem\_write t \$ map t f2 \$ map t f1 \$ mem\_read t
\end{enumerate}

\subsection{Reduce}
\begin{enumerate}
    \item mem\_write 1 \$ reduce t f \$ mem\_read t
    \item mem\_write 1 \$ reduce t f \$ deserialize t f \$ mem\_read 1
        \subitem Note everything after deserialize fires every t'th clock cycle
\end{enumerate}

\subsection{Array Dimension Conversions}
\begin{enumerate}
    \item mem\_write $\frac{t}{p}$ \$ partition p t \$ mem\_read t
        \subitem Note that the element type mem\_write is writing is T[p],
        and it writes $\frac{t}{p}$ of them every clock.
    \item mem\_write t \$ flatten t \$ partition t \$ mem\_read t
    \item mem\_write 1 \$ flatten t \$ partition t \$ deserialize t \$ mem\_read t
        \subitem Note everything after deserialize fires onces every t'th clock 
        cycle
    \item mem\_write 1 \$ down t \$ up t \$ mem\_read 1
\end{enumerate}

\section{Advanced Applications}

\subsection{}
These are operations that are combinations of the basic ones. They are also
applica
\begin{enumerate}
    \item t
\end{enumerate}


\end{document}
