Implementations of upsampling an image of size N by a factor of k:


1/k source px/clock:
======================================

upsample_slow n k :: {1,T} -> {k,T}

upsample_slow n k = map_t n (up_t k)  


1 px/clock: 
======================================

upsample_1 n k :: {1,T} -> {1,T[K]}

upsample_1 n k = map_t n (up_x k)  


N/k source px/clock: 
======================================

upsample_nk n k :: {1,T[n]} -> {1,T[n][k]}

upsample_nk n k = flatten k $ map_x n (up_t k)


N source px/clock
======================================

upsample_nk n k :: {1,T[n]} -> {1,T[n][k]}

upsample_nk n k = map_x n (up_x k)

or one might prefer this, where I flatten the 2D vector output into 1D:

upsample_nk n k :: {1,T[n]} -> {1,T[n*k]}

upsample_nk n k = arr_flatten n k $ map_x n (up_x k)


P source px/clock
======================================

upsample_p n k :: {1,T[p]} -> {1,T[p][k]}

upsample_p n k = map_t n/p (map_x p up_x k)

or the 1D output version:

upsample_p n k :: {1,T[p]} -> {1,T[p*k]}

upsample_p n k = map_t n/p (arr_flatten p k . (map_x p up_x k))
