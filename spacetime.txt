SpaceTime Functions

up_x k :: {1,T} -> {1,T[k]} # also referred to as repeat k or broadcast k
   area(up_x k) = k
   time(up_x k) = 1

down_x k :: {1,T[k]} -> {1,T} # also referred to as select k i 
   area(down_x k) = k
   time(down_x k) = 1

stencil_x k n :: {1,T[n]} -> {1,T[n-k][k]}
   area(stencil_x k n) = k*n
   time(stencil_x k n) = 1

fold_x k f id :: {1,S[k]} -> {1,T}
   area(fold_x k f) = k*area(f)
   time(fold_x k f) = time(f)

map_x k f :: {1,S[k]} -> {1,T[k]}
   area(map_x k f) = k*area(f)
   time(map_x k f) = time(f)


up_t k :: {1,T} -> {k,T}  
   area(up_t k) = 1
   time(up_t k) = k

down_t k :: {k,T} -> {1,T} 
   area(down_t k) = 1
   time(down_t k) = k

# stencil = shift
shift k :: {1,T} -> {1,T[k]} 
   area(shift k) = k
   time(shift k) = k

Notes: shift gives k elements, with 1 at a time increment in index
   
fold_t k f id :: {k,S} -> {1,T}
   area(fold_t k f) = area(f)
   time(fold_t k f) = k * time(f)

map_t f :: {1,S} -> {1,T)
   area(map_t f) = area(f)
   time(map_t f) = time(f)
 
partition i :: {1,T[i*j]} -> {i,T[j]}
   area(partition i) = i*j 
   time(partition i) = i

Notes: partition splits into disjoint groups of i elements that are
emitted sequentially.  Partition increases rate.
   
flatten i :: {i,T[j]} -> {1,T[i*j]}
   area(flatten i) = i*j
   time(flatten i) = i

Notes: flatten takes a stream of elements and squished them together
       into a stream of larger elements emitted at a lower
       rate. (Flatten decreases rate)
   
verbal defintion of box: given a stream of arrays of length n and type S, convert them into arrays of length n of type T, where T is constructed by applying + to the elements i, i-1, ..., i-k of the input stream.
box in time:
box_t n k id :: int -> int -> {1, T} -> {1, T}
box_t n k f = map_t (fold_t k (+) id) $ stencil_t k
area(box_t n k) = area(+) + k
time(box_t n k) = n * k

box fully parallel in space:
box_x n k :: int -> int -> {1, T[n]} -> {1, T[n-k]}
box_x n k = write (n-k) $ map_x (n-k) (fold_x k (+) 0) $ stencil_x k n $ read n
area(box_x n k) = n*k*(1+area(+))
time(box_f n k) = (+)

Convert Between Different Amounts of Parallelism

read n k = read n pixels, k at a time
Note: read n k $ read n k == read n p, as can just short circuit the second read

a_x is arbitrarily parallel, this one takes in whole array at start
box_a_x n k p :: {1, n, T[n/p]} -> {1, n, T[floor((n-k)/p)]}
box_a_x n k p = map_x ((n/p) - (is first iteration ? k : 0)) (fold_x k (+) 0) k $ stencil_x k (n/p) $ read n (n/p)
area(box_a_x) = area(n/p * +) + area(n/p * stencil(k)) = n/p*k*area(+) + k
time(box_a_x) = p*max(time(map_x (fold_x k)), stencil_x k (n/P))
	      = p*max((+), stencil) = p*(x)
 note: this works as long as stencil remembers elements of a prior input from read for the next one.

box_nested_ax :: {1, n, 

conv_a_x n k p f id = partition $ (this is actually not neccesary, the parittion can handle the array of arrays of length n just fine, still split them into p pieces - need somehting here to convert the stencil collection of arrays into one big array, so partition can split up the arrays and feed them out one tick at a time) $ stencil_x k n

why is it important to be able to transform between them if I can just get arbtrary parallelism directly? Should I read the thesis to get that?





